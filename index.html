<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Garden – Modular Single File (Three.js + Box‑Man + Glass Room)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    .hud { position: fixed; left: 12px; top: 12px; color: #fff; font: 14px/1.4 system-ui, sans-serif; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px; user-select: none; z-index: 3; white-space: pre; }
    .name-tag { position: fixed; left: 0; top: 0; transform: translate(-50%, -100%); padding: 4px 8px; border-radius: 6px; font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #EAF2FF; background: rgba(18,18,24,.78); border: 1px solid rgba(255,255,255,.15); box-shadow: 0 2px 8px rgba(0,0,0,.35); pointer-events: none; z-index: 4; white-space: nowrap; }
    .name-tag.hidden { display: none; }
  </style>
</head>
<body>
  <!-- HUD: koordinatlar + yön -->
  <div class="hud" id="hud">—</div>
  <!-- Avatar etiketi -->
  <div class="name-tag" id="nameTag">macaris64</div>

  <!-- import map: three + orbit -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "orbit": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <!-- Utils -->
  <script type="module" id="mod-utils">
    export const deg = (rad)=> (rad * 180 / Math.PI);
    export const fmt = (n)=> Number(n).toFixed(2);
  </script>

  <!-- Scene Setup -->
  <script type="module" id="mod-scene">
    export function createSceneSetup(THREE, OrbitControls){
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87b7ff);

      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 4000);
      camera.position.set(0, 10, 16);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enablePan = false;
      controls.minDistance = 6; controls.maxDistance = 100; controls.maxPolarAngle = Math.PI * 0.49;
      controls.enableKeys = false; controls.keys = {}; controls.keyPanSpeed = 0;
      controls.target.set(0, 2, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(60,100,40); dl.castShadow = true; dl.shadow.mapSize.set(2048,2048); scene.add(dl);

      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
      });

      return { scene, camera, renderer, controls };
    }
  </script>

  <!-- Input -->
  <script type="module" id="mod-input">
    export function createInput(){
      const keys = { w:false, a:false, s:false, d:false, space:false };
      const mapKey = (e)=>{ const k=e.key; if(k===' '||k==='Spacebar') return 'space'; const low=(k||'').toLowerCase(); return low==='space'?'space':low; };
      addEventListener('keydown',e=>{const k=mapKey(e); if(k in keys){keys[k]=true; if(k==='space') e.preventDefault();}});
      addEventListener('keyup',  e=>{const k=mapKey(e); if(k in keys){keys[k]=false; if(k==='space') e.preventDefault();}});
      return keys;
    }
  </script>

  <!-- Garden (ground + stage + lights + RIGHT side screen) -->
  <script type="module" id="mod-garden">
    export function createGarden(THREE, scene){
      const planeSize = 400; // büyük bahçe
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(planeSize, planeSize),
        new THREE.MeshLambertMaterial({ color: 0x2faa2f })
      );
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

      // Sahne (X sabit solda, Z ortada)
      const STAGE_W = 90, STAGE_D = 90, STAGE_H = 15; // yarı yükseklik
      const stageMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.8 });
      const stage = new THREE.Mesh(new THREE.BoxGeometry(STAGE_W, STAGE_H, STAGE_D), stageMat);
      stage.castShadow = true; stage.receiveShadow = true;
      stage.position.set(-planeSize/2 + STAGE_W/2, STAGE_H/2, 0);
      scene.add(stage);

      // Sahne ışıkları: üstten 3 spot
      const spots = new THREE.Group();
      const spotY = STAGE_H + 20;
      const zOff = STAGE_D * 0.3;
      [ -zOff, 0, zOff ].forEach((z)=>{
        const s = new THREE.SpotLight(0xffffff, 1.2, 120, THREE.MathUtils.degToRad(28), 0.4, 1.0);
        s.position.set(stage.position.x, spotY, z);
        s.target.position.set(stage.position.x, STAGE_H*0.5, 0);
        scene.add(s.target);
        s.castShadow = true;
        spots.add(s);
      });
      scene.add(spots);

      // *** Sunum tahtası (kare) — sahnenin önünün hemen sağı ***
      // Uç noktalar: (-110, 10, -50) -> (-110, 10, -130)
      const boardSize = 80;                   // kare kenar
      const boardX = -110;                    // düzlem X sabit
      const boardZMin = -130, boardZMax = -50;// Z aralığı
      const boardZCenter = (boardZMin + boardZMax) * 0.5; // -90
      const boardYCenter = boardSize * 0.5;   // 40 (taban 0)
      const board = new THREE.Mesh(
        new THREE.PlaneGeometry(boardSize, boardSize),
        new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.0, roughness:0.25, side: THREE.DoubleSide })
      );
      board.position.set(boardX, boardYCenter, boardZCenter);
      board.rotation.y = -Math.PI/2; // doğuya bakar; düzlem YZ üzerinde
      scene.add(board);

      // --- Sunum tahtası ÇARPIŞMA fonksiyonu (dikey düzlem, X=boardX) ---
      function boardBlock(pos, prev, half = 1){
        // Tahtanın kapsadığı Y ve Z aralığı
        const yMin = 0, yMax = boardSize; // taban sahne tabanı ile hizalı
        const zMin = boardZMin, zMax = boardZMax;
        const withinZ = (pos.z > zMin - half && pos.z < zMax + half) || (prev.z > zMin - half && prev.z < zMax + half);
        const withinY = (pos.y - half < yMax && pos.y + half > yMin) || (prev.y - half < yMax && prev.y + half > yMin);
        if (!withinZ || !withinY) return;
        // Düzlemi geçiş tespiti: farklı taraflarda mıyız?
        const sidePrev = Math.sign(prev.x - boardX);
        const sideNow  = Math.sign(pos.x  - boardX);
        if (sidePrev === 0 && sideNow === 0) return; // tam üzerindeyse sessizce geç
        if (sidePrev === 0 && sideNow !== 0){
          // Üstünde başlayıp bir tarafa kaymış; geri it
          pos.x = boardX + (sideNow > 0 ? half : -half);
          return;
        }
        if (sidePrev !== 0 && sideNow !== 0 && sidePrev !== sideNow){
          // Düzlemi kesmiş -> geri al
          pos.x = prev.x;
          return;
        }
      }

      function insideStageXZ(x, z, half=1){
        const sxMin = stage.position.x - STAGE_W/2 - half,
              sxMax = stage.position.x + STAGE_W/2 + half,
              szMin = stage.position.z - STAGE_D/2 - half,
              szMax = stage.position.z + STAGE_D/2 + half;
        return x>=sxMin && x<=sxMax && z>=szMin && z<=szMax;
      }
      const groundYAt = (x,z,half=1)=> insideStageXZ(x,z,half) ? 9999 : 0;

      return { ground, planeSize, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt, boardBlock };
    }
  </script>

  <!-- Glass Room (camlı oda) – Alt siyah bant + üst hücreler (Siyah > Cam) + Cam çatı; Kapı BATI -->
  <script type="module" id="mod-glassroom">
    export function createGlassRoom(THREE, scene, { w, d, position, doorRatio = 0.35 }){
      const baseH  = 2.6;      // avatar üstü alt bant
      const upperH = 15.0;     // sahne yüksekliğinin yarısı
      const h = baseH + upperH;
      const t = 0.25;

      const group = new THREE.Group();
      const matPillar = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.6, roughness: 0.5 });
      const matGlass  = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, metalness: 0.0, roughness: 0.15 });
      const matFloor  = new THREE.MeshStandardMaterial({ color: 0x303030 });

      const floor = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matFloor);
      floor.position.y = 0; floor.receiveShadow = true; group.add(floor);

      // Alt bant (kapı BATI boşluklu)
      const doorW = Math.max(1.2, d * doorRatio);
      const segZ = Math.max(0, (d - doorW) / 2);
      const northBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); northBase.position.set(0, baseH/2, -d/2); group.add(northBase);
      const southBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); southBase.position.set(0, baseH/2,  d/2); group.add(southBase);
      const eastBase  = new THREE.Mesh(new THREE.BoxGeometry(d, baseH, t), matPillar); eastBase.rotation.y = Math.PI/2; eastBase.position.set( w/2, baseH/2, 0); group.add(eastBase);
      if (segZ > 0) {
        const westBaseL = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseL.rotation.y = Math.PI/2; westBaseL.position.set(-w/2, baseH/2, -(doorW/2 + segZ/2)); group.add(westBaseL);
        const westBaseR = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseR.rotation.y = Math.PI/2; westBaseR.position.set(-w/2, baseH/2,  (doorW/2 + segZ/2)); group.add(westBaseR);
      }

      // Üst bant: hücreler (Siyah kolon geniş > Cam panel dar)
      const colW=2.4, panelW=1.2, cell=colW+panelW; const yUpperMid = baseH + upperH/2;
      function buildUpperStrip({ along, L, fixedVal, isWestDoor=false }){
        const count = Math.ceil(L / cell);
        for (let i=0;i<count;i++){
          const base = -L/2 + i*cell;
          const colLen = Math.min(colW, L - i*cell);
          if (colLen > 0){
            const col = new THREE.Mesh(along==='x'? new THREE.BoxGeometry(colLen, upperH, t) : new THREE.BoxGeometry(t, upperH, colLen), matPillar);
            if (along==='x') col.position.set(base + colLen/2, yUpperMid, fixedVal); else col.position.set(fixedVal, yUpperMid, base + colLen/2);
            if (!(isWestDoor && Math.abs(col.position.z) <= doorW/2)) group.add(col);
          }
          const panLen = Math.min(panelW, L - (i*cell + colLen));
          if (panLen > 0){
            const pan = new THREE.Mesh(along==='x'? new THREE.BoxGeometry(panLen, upperH, t) : new THREE.BoxGeometry(t, upperH, panLen), matGlass);
            if (along==='x') pan.position.set(base + colLen + panLen/2, yUpperMid, fixedVal); else pan.position.set(fixedVal, yUpperMid, base + colLen + panLen/2);
            if (!(isWestDoor && Math.abs(pan.position.z) <= doorW/2)) group.add(pan);
          }
        }
      }
      buildUpperStrip({ along:'x', L:w, fixedVal:-d/2, isWestDoor:false });
      buildUpperStrip({ along:'x', L:w, fixedVal: d/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal: w/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal:-w/2, isWestDoor:true  });

      // Cam çatı
      const roof = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matGlass);
      roof.position.set(0, h + t/2, 0); group.add(roof);

      group.position.copy(position);
      scene.add(group);

      // Çarpışma mantığı (değişmedi)
      const hx = w/2, hz = d/2; const ixMin=-hx, ixMax=hx, izMin=-hz, izMax=hz;
      function isInsideInner(lx, lz, half){ return (lx > ixMin + half && lx < ixMax - half && lz > izMin + half && lz < izMax - half); }
      function roomBlock(pos, prev, half = 1){
        const lx=pos.x-position.x, lz=pos.z-position.z, lpx=prev.x-position.x, lpz=prev.z-position.z;
        const prevInside=isInsideInner(lpx,lpz,half), nowInside=isInsideInner(lx,lz,half);
        const inDoorZ = Math.abs(lz) <= doorW/2; const westInnerPlane = ixMin + half;
        const crossingWestOut=(lpx>=westInnerPlane && lx<westInnerPlane), crossingWestIn=(lpx<=westInnerPlane && lx>westInnerPlane);
        if (prevInside && !nowInside){ const throughDoor=crossingWestOut && inDoorZ; if(!throughDoor){ pos.x=prev.x; pos.z=prev.z; return; } }
        if (!prevInside && nowInside){ const throughDoor=crossingWestIn  && inDoorZ; if(!throughDoor){ pos.x=prev.x; pos.z=prev.z; return; } }
        if (prevInside && nowInside){
          pos.x = Math.min(Math.max(pos.x, position.x + ixMin + half), position.x + ixMax - half);
          pos.z = Math.min(Math.max(pos.z, position.z + izMin + half), position.z + izMax - half);
        }
      }
      return { room: group, height: h, block: roomBlock };
    }
  </script>

  <!-- Avatar Factory + Animator -->
  <script type="module" id="mod-entities">
    export function createAvatarMesh(THREE, materials){
      const { skin, limb, black, white } = materials;
      const gBox = (x,y,z,m)=>{ const mesh=new THREE.Mesh(new THREE.BoxGeometry(x,y,z), m); mesh.castShadow=true; return mesh; };
      const root  = new THREE.Group();
      const torso = gBox(1.2, 1.6, 0.6, skin); torso.position.y = 1.6; root.add(torso);
      const head  = gBox(0.9, 0.9, 0.9, skin); head.position.y  = 2.65; root.add(head);
      const face = new THREE.Group(); face.position.set(0, 2.65, 0.455);
      const eyeW_L = gBox(0.22,0.18,0.02, white); eyeW_L.position.set(-0.22,0.08,0);
      const eyeW_R = eyeW_L.clone(); eyeW_R.position.x *= -1;
      const eye_L  = gBox(0.08,0.08,0.03, black); eye_L.position.set(-0.22,0.08,0.02);
      const eye_R  = eye_L.clone(); eye_R.position.x *= -1;
      const brow_L = gBox(0.28,0.05,0.03, black); brow_L.position.set(-0.22,0.2,0.01);
      const brow_R = brow_L.clone(); brow_R.position.x *= -1;
      face.add(eyeW_L, eyeW_R, eye_L, eye_R, brow_L, brow_R); root.add(face);
      const arm = gBox(0.35, 1.2, 0.35, limb), leg = gBox(0.45, 1.4, 0.45, limb);
      const aL = new THREE.Group(), aR = new THREE.Group(), lL = new THREE.Group(), lR = new THREE.Group();
      const armL = arm.clone(), armR = arm.clone(), legL = leg.clone(), legR = leg.clone();
      armL.position.set(0,-0.6,0); armR.position.copy(armL.position);
      legL.position.set(0,-0.7,0); legR.position.copy(legL.position);
      aL.position.set(-0.9, 2.2, 0); aR.position.set( 0.9, 2.2, 0);
      lL.position.set(-0.3, 1.4, 0); lR.position.set( 0.3, 1.4, 0);
      aL.add(armL); aR.add(armR); lL.add(legL); lR.add(legR);
      root.add(aL,aR,lL,lR);
      root.userData.limbs = { aL, aR, lL, lR };
      return root;
    }

    export function AvatarFactory(THREE){
      const materials = {
        skin:  new THREE.MeshStandardMaterial({ color: 0xffe0bd }),
        limb:  new THREE.MeshStandardMaterial({ color: 0x888888 }),
        black: new THREE.MeshStandardMaterial({ color: 0x111111 }),
        white: new THREE.MeshStandardMaterial({ color: 0xffffff }),
      };
      return {
        create(){
          const avatar = createAvatarMesh(THREE, materials);
          return avatar;
        }
      };
    }

    // Hareket/animasyon mantığı — DEĞİŞMEDİ
    export function updateAvatar(THREE, dt, avatar, keys, camera, controls, helpers){
      if(!avatar) return;
      const { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock, boardBlock } = helpers;
      const AVATAR_SIZE = 2;

      const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

      const moveX = (keys.d?1:0) + (keys.a?-1:0);
      const moveZ = (keys.s?1:0) + (keys.w?-1:0);
      const move = new THREE.Vector3().addScaledVector(forward, -moveZ).addScaledVector(right, moveX);
      if (move.lengthSq()>0) move.normalize();

      avatar.userData.vel ??= new THREE.Vector3(0,0,0);
      const vel = avatar.userData.vel;
      const speed = 18, gravity = 22, jumpSpeed = 8.5, friction = 10;
      vel.x += (move.x*speed - vel.x)*Math.min(1, dt*8);
      vel.z += (move.z*speed - vel.z)*Math.min(1, dt*8);
      if (move.lengthSq()===0){ const damp=Math.max(0,1-friction*dt); vel.x*=damp; vel.z*=damp; }

      const gY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      const onGround = Math.abs(avatar.position.y - gY) < 0.01;
      if (onGround && keys.space) vel.y = jumpSpeed; else if (!onGround) vel.y -= gravity*dt; else vel.y = 0;

      const prev = avatar.position.clone();
      avatar.position.x += vel.x*dt; avatar.position.y = Math.max(avatar.position.y + vel.y*dt, AVATAR_SIZE/2); avatar.position.z += vel.z*dt;

      const minX = -planeSize/2 + AVATAR_SIZE/2, maxX = planeSize/2 - AVATAR_SIZE/2, minZ = -planeSize/2 + AVATAR_SIZE/2, maxZ = planeSize/2 - AVATAR_SIZE/2;
      avatar.position.x = Math.min(Math.max(avatar.position.x, minX), maxX);
      avatar.position.z = Math.min(Math.max(avatar.position.z, minZ), maxZ);

      if (insideStageXZ(avatar.position.x, avatar.position.z) && (avatar.position.y - AVATAR_SIZE/2) < (stageTopY + 0.01)){
        avatar.position.x = prev.x; avatar.position.z = prev.z; vel.x = 0; vel.z = 0;
      }

      // Camlı oda çarpışması
      if (typeof roomBlock === 'function'){
        roomBlock(avatar.position, prev, AVATAR_SIZE/2);
      }
      // Sunum tahtası çarpışması
      if (typeof boardBlock === 'function'){
        boardBlock(avatar.position, prev, AVATAR_SIZE/2);
      }

      const nGY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      if (avatar.position.y < nGY){ avatar.position.y = nGY; vel.y = 0; }

      if (vel.lengthSq()>0.0001){ const dirY = Math.atan2(vel.x, vel.z); if(!Number.isNaN(dirY)) avatar.rotation.y = dirY; }

      // Animasyon stabilitesi — aynı
      avatar.userData.animBlend ??= 0;            
      avatar.userData.swingTime ??= 0;            
      const speed2D = Math.hypot(vel.x, vel.z);
      const targetRun = Math.min(1, speed2D / speed);
      const blendK = 12; 
      avatar.userData.animBlend += (targetRun - avatar.userData.animBlend) * Math.min(1, dt * blendK);
      if (avatar.userData.animBlend < 0.05) avatar.userData.swingTime = 0; 
      const freq = THREE.MathUtils.lerp(2.0, 6.0, avatar.userData.animBlend);
      avatar.userData.swingTime += dt * freq;
      const amp  = THREE.MathUtils.lerp(0.1, 0.6, avatar.userData.animBlend);
      const s = Math.sin(avatar.userData.swingTime);
      const { aL, aR, lL, lR } = avatar.userData.limbs;
      aL.rotation.x =  s * amp;
      aR.rotation.x = -s * amp;
      lL.rotation.x = -s * amp;
      lR.rotation.x =  s * amp;
      if(!onGround){ aL.rotation.x += 0.6; aR.rotation.x += 0.6; }

      const desiredTarget = avatar.position.clone(); const deltaTarget = desiredTarget.clone().sub(controls.target); camera.position.add(deltaTarget); controls.target.copy(avatar.position);
    }
  </script>

  <!-- Main -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'orbit';

    // Inline dynamic importer — avoids bare specifiers
    async function importById(id){
      const el = document.getElementById(id);
      if(!el) throw new Error(`Modül bulunamadı: ${id}`);
      const code = el.textContent;
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      try { return await import(url); } finally { URL.revokeObjectURL(url); }
    }

    const utils                = await importById('mod-utils');
    const { createSceneSetup } = await importById('mod-scene');
    const { createInput }      = await importById('mod-input');
    const { createGarden }     = await importById('mod-garden');
    const { createGlassRoom }  = await importById('mod-glassroom');
    const { AvatarFactory, updateAvatar } = await importById('mod-entities');

    const hud = document.getElementById('hud');
    const nameTag = document.getElementById('nameTag');

    const { scene, camera, renderer, controls } = createSceneSetup(THREE, OrbitControls);
    const keys = createInput();

    const { planeSize, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt, boardBlock } = createGarden(THREE, scene);
    const stageTopY = stage.position.y + STAGE_H/2;

    // Camlı oda: sahne ile aynı boyut; haritanın en sağ kenarı
    const roomPos = new THREE.Vector3( planeSize/2 - STAGE_W/2, 0, 0 );
    const { room: glassRoom, block: roomBlock } = createGlassRoom(THREE, scene, { w: STAGE_W, d: STAGE_D, position: roomPos });

    // Avatar: factory ile oluştur
    const avatarFactory = AvatarFactory(THREE);
    const avatar = avatarFactory.create();
    scene.add(avatar);

    // Spawn: odanın içinde, sahneye (batıya) dönük
    avatar.position.set(roomPos.x, 1, roomPos.z);
    avatar.rotation.y = -Math.PI/2; // sahneye bakış

    // Kamera: sahneye doğru baksın
    camera.position.set(avatar.position.x + 12, avatar.position.y + 8, avatar.position.z + 0);
    controls.target.copy(avatar.position);

    function updateNameTag(){
      const pos = avatar.position.clone();
      pos.y += 3.2; // kafanın biraz üstü
      pos.project(camera);
      const out = (Math.abs(pos.x) > 1 || Math.abs(pos.y) > 1 || pos.z > 1);
      if(out){ nameTag.classList.add('hidden'); return; }
      nameTag.classList.remove('hidden');
      const x = (pos.x * 0.5 + 0.5) * innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * innerHeight;
      nameTag.style.transform = `translate(-50%, -100%) translate(${x}px, ${y}px)`;
    }

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      updateAvatar(THREE, dt, avatar, keys, camera, controls, { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock, boardBlock });
      controls.update();
      renderer.render(scene, camera);

      // HUD
      const heading = ((utils.deg(avatar.rotation.y) % 360) + 360) % 360;
      hud.textContent = `x: ${utils.fmt(avatar.position.x)}\ny: ${utils.fmt(avatar.position.y)}\nz: ${utils.fmt(avatar.position.z)}\nrotY: ${heading.toFixed(1)}°`;
      updateNameTag();
    }
    animate();
  </script>
</body>
</html>
