<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Garden – Modular Single File (Refactor + GlassRoom Roof)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    .hud { position: fixed; left: 12px; top: 12px; color: #fff; font: 14px/1.4 system-ui, sans-serif; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px; user-select: none; z-index: 3; white-space: pre; }
    .name-tag { position: fixed; left: 0; top: 0; transform: translate(-50%, -100%); padding: 4px 8px; border-radius: 6px; font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #EAF2FF; background: rgba(18,18,24,.78); border: 1px solid rgba(255,255,255,.15); box-shadow: 0 2px 8px rgba(0,0,0,.35); pointer-events: none; z-index: 4; white-space: nowrap; }
    .name-tag.hidden { display: none; }
  </style>
</head>
<body>
  <!-- HUD: koordinatlar + yön -->
  <div class="hud" id="hud">—</div>
  <!-- Avatar etiketi -->
  <div class="name-tag" id="nameTag">Udemy</div>

  <!-- import map: three + orbit -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "orbit": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <!-- Utils -->
  <script type="module" id="mod-utils">
    export const deg = (rad)=> (rad * 180 / Math.PI);
    export const fmt = (n)=> Number(n).toFixed(2);
  </script>

  <!-- Scene Setup -->
  <script type="module" id="mod-scene">
    export function createSceneSetup(THREE, OrbitControls){
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87b7ff);

      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 4000);
      camera.position.set(0, 10, 16);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enablePan = false;
      controls.minDistance = 6; controls.maxDistance = 100; controls.maxPolarAngle = Math.PI * 0.49;
      controls.enableKeys = false; controls.keys = {}; controls.keyPanSpeed = 0;
      controls.target.set(0, 2, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(60,100,40); dl.castShadow = true; dl.shadow.mapSize.set(2048,2048); scene.add(dl);

      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
      });

      return { scene, camera, renderer, controls };
    }
  </script>

  <!-- Input -->
  <script type="module" id="mod-input">
    export function createInput(){
      const keys = { w:false, a:false, s:false, d:false, space:false };
      const mapKey = (e)=>{ const k=e.key; if(k===' '||k==='Spacebar') return 'space'; const low=(k||'').toLowerCase(); return low==='space'?'space':low; };
      addEventListener('keydown',e=>{const k=mapKey(e); if(k in keys){keys[k]=true; if(k==='space') e.preventDefault();}});
      addEventListener('keyup',  e=>{const k=mapKey(e); if(k in keys){keys[k]=false; if(k==='space') e.preventDefault();}});
      return keys;
    }
  </script>

  <!-- Garden (ground + stage) -->
  <script type="module" id="mod-garden">
    export function createGarden(THREE, scene){
      const planeSize = 400; // aynı
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(planeSize, planeSize),
        new THREE.MeshLambertMaterial({ color: 0x2faa2f })
      );
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

      // Sahne: X/Y aynı, Z ortada; derinlik 90
      const STAGE_W = 90, STAGE_D = 90, STAGE_H = 30;
      const stage = new THREE.Mesh(new THREE.BoxGeometry(STAGE_W, STAGE_H, STAGE_D), new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.8 }));
      stage.castShadow = true; stage.receiveShadow = true;
      stage.position.set(-planeSize/2 + STAGE_W/2, STAGE_H/2, 0);
      scene.add(stage);

      function insideStageXZ(x, z, half=1){
        const sxMin = stage.position.x - STAGE_W/2 - half,
              sxMax = stage.position.x + STAGE_W/2 + half,
              szMin = stage.position.z - STAGE_D/2 - half,
              szMax = stage.position.z + STAGE_D/2 + half;
        return x>=sxMin && x<=sxMax && z>=szMin && z<=szMax;
      }
      const groundYAt = (x,z,half=1)=> insideStageXZ(x,z,half) ? 9999 : 0;

      return { ground, planeSize, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt };
    }
  </script>

  <!-- Glass Room (camlı oda) – Alt bant: yüksek siyah; Üst bant: STAGE_H/2 hücreler (Siyah > Cam) | Kapı BATI duvarında | ÜSTÜ CAM KAPAK -->
  <script type="module" id="mod-glassroom">
    export function createGlassRoom(THREE, scene, { w, d, position, doorRatio = 0.35 }){
      // Alt bant (baseH) avatar'dan yüksek; Üst bant (upperH) sahne yüksekliğinin yarısı; Toplam yükseklik h = baseH + upperH
      const baseH  = 2.6;      // avatar (≈2) üstünde, önceki görünüme yakın
      const upperH = 15.0;     // STAGE_H/2 (30/2)
      const h = baseH + upperH;
      const t = 0.25;           // kalınlık

      const group = new THREE.Group();

      // Malzemeler
      const matPillar = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.6, roughness: 0.5 }); // siyah
      const matGlass  = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, metalness: 0.0, roughness: 0.15 }); // beyaz cam
      const matFloor  = new THREE.MeshStandardMaterial({ color: 0x303030 });

      // Zemin
      const floor = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matFloor);
      floor.position.y = 0; floor.receiveShadow = true; group.add(floor);

      // === ALT BANT: TAM SİYAH (avatar'dan yüksek) ===
      const northBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); northBase.position.set(0, baseH/2, -d/2); group.add(northBase);
      const southBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); southBase.position.set(0, baseH/2,  d/2); group.add(southBase);
      const eastBase  = new THREE.Mesh(new THREE.BoxGeometry(d, baseH, t), matPillar); eastBase.rotation.y = Math.PI/2; eastBase.position.set( w/2, baseH/2, 0); group.add(eastBase);
      const doorW = Math.max(1.2, d * doorRatio);
      const segZ = Math.max(0, (d - doorW) / 2);
      if (segZ > 0) {
        const westBaseL = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseL.rotation.y = Math.PI/2; westBaseL.position.set(-w/2, baseH/2, -(doorW/2 + segZ/2)); group.add(westBaseL);
        const westBaseR = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseR.rotation.y = Math.PI/2; westBaseR.position.set(-w/2, baseH/2,  (doorW/2 + segZ/2)); group.add(westBaseR);
      }

      // === ÜST BANT: HÜCRELER (Siyah kolon geniş > Cam panel dar) ===
      const colW   = 2.4;   // siyah kolon daha geniş
      const panelW = 1.2;   // cam panel daha dar
      const cell   = colW + panelW;
      const yUpperMid = baseH + upperH/2;

      function buildUpperStrip({ along, L, fixedVal, isWestDoor=false }){
        const count = Math.ceil(L / cell);
        for (let i=0;i<count;i++){
          const base = -L/2 + i*cell;
          // Kolon (geniş)
          const colLen = Math.min(colW, L - i*cell);
          if (colLen > 0){
            const col = new THREE.Mesh(
              along==='x' ? new THREE.BoxGeometry(colLen, upperH, t) : new THREE.BoxGeometry(t, upperH, colLen),
              matPillar
            );
            if (along==='x') col.position.set(base + colLen/2, yUpperMid, fixedVal);
            else              col.position.set(fixedVal, yUpperMid, base + colLen/2);
            if (!(isWestDoor && Math.abs(col.position.z) <= doorW/2)) group.add(col);
          }
          // Panel (dar)
          const panLen = Math.min(panelW, L - (i*cell + colLen));
          if (panLen > 0){
            const pan = new THREE.Mesh(
              along==='x' ? new THREE.BoxGeometry(panLen, upperH, t) : new THREE.BoxGeometry(t, upperH, panLen),
              matGlass
            );
            if (along==='x') pan.position.set(base + colLen + panLen/2, yUpperMid, fixedVal);
            else              pan.position.set(fixedVal, yUpperMid, base + colLen + panLen/2);
            if (!(isWestDoor && Math.abs(pan.position.z) <= doorW/2)) group.add(pan);
          }
        }
      }

      // Kuzey/Güney/Doğu/Batı üst bantları
      buildUpperStrip({ along:'x', L:w, fixedVal:-d/2, isWestDoor:false });
      buildUpperStrip({ along:'x', L:w, fixedVal: d/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal: w/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal:-w/2, isWestDoor:true });

      // === ÜST KAPAK: BEYAZ CAM ÇATI ===
      const roof = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matGlass);
      roof.position.set(0, h + t/2, 0); // duvarların üst hizasından hemen sonra ince bir cam plaka
      roof.castShadow = false; roof.receiveShadow = false;
      group.add(roof);

      group.position.copy(position);
      scene.add(group);

      // --- Çarpışma (iç AABB + KAPI BATI) — LOGIC AYNI ---
      const hx = w/2, hz = d/2;
      const ixMin = -hx, ixMax =  hx; // iç limitler
      const izMin = -hz, izMax =  hz;

      function isInsideInner(lx, lz, half){
        return (lx > ixMin + half && lx < ixMax - half && lz > izMin + half && lz < izMax - half);
      }

      function roomBlock(pos, prev, half = 1){
        const lx  = pos.x  - position.x;  const lz  = pos.z  - position.z;
        const lpx = prev.x - position.x;  const lpz = prev.z - position.z;

        const prevInside = isInsideInner(lpx, lpz, half);
        const nowInside  = isInsideInner(lx,  lz,  half);

        // Kapı bandı (BATI: x ~ ixMin)
        const inDoorZ = Math.abs(lz) <= doorW/2;

        // İçeriden dışarı / dışarıdan içeri — sadece batı kapıdan izin ver
        const westInnerPlane = ixMin + half;
        const crossingWestOut = (lpx >= westInnerPlane && lx <  westInnerPlane);
        const crossingWestIn  = (lpx <= westInnerPlane && lx >  westInnerPlane);
        if (prevInside && !nowInside){
          const throughDoor = crossingWestOut && inDoorZ;
          if (!throughDoor){ pos.x = prev.x; pos.z = prev.z; return; }
        }
        if (!prevInside && nowInside){
          const throughDoor = crossingWestIn && inDoorZ;
          if (!throughDoor){ pos.x = prev.x; pos.z = prev.z; return; }
        }

        // İçerideyken duvar clamp'i
        if (prevInside && nowInside){
          pos.x = Math.min(Math.max(pos.x, position.x + ixMin + half), position.x + ixMax - half);
          pos.z = Math.min(Math.max(pos.z, position.z + izMin + half), position.z + izMax - half);
        }
      }

      return { room: group, height: h, block: roomBlock };
    }
  </script>

  <!-- Avatar Factory + Animator -->
  <script type="module" id="mod-entities">
    export function createAvatarMesh(THREE, materials){
      const { skin, limb, black, white } = materials;
      const gBox = (x,y,z,m)=>{ const mesh=new THREE.Mesh(new THREE.BoxGeometry(x,y,z), m); mesh.castShadow=true; return mesh; };
      const root  = new THREE.Group();
      const torso = gBox(1.2, 1.6, 0.6, skin); torso.position.y = 1.6; root.add(torso);
      const head  = gBox(0.9, 0.9, 0.9, skin); head.position.y  = 2.65; root.add(head);
      const face = new THREE.Group(); face.position.set(0, 2.65, 0.455);
      const eyeW_L = gBox(0.22,0.18,0.02, white); eyeW_L.position.set(-0.22,0.08,0);
      const eyeW_R = eyeW_L.clone(); eyeW_R.position.x *= -1;
      const eye_L  = gBox(0.08,0.08,0.03, black); eye_L.position.set(-0.22,0.08,0.02);
      const eye_R  = eye_L.clone(); eye_R.position.x *= -1;
      const brow_L = gBox(0.28,0.05,0.03, black); brow_L.position.set(-0.22,0.2,0.01);
      const brow_R = brow_L.clone(); brow_R.position.x *= -1;
      face.add(eyeW_L, eyeW_R, eye_L, eye_R, brow_L, brow_R); root.add(face);
      const arm = gBox(0.35, 1.2, 0.35, limb), leg = gBox(0.45, 1.4, 0.45, limb);
      const aL = new THREE.Group(), aR = new THREE.Group(), lL = new THREE.Group(), lR = new THREE.Group();
      const armL = arm.clone(), armR = arm.clone(), legL = leg.clone(), legR = leg.clone();
      armL.position.set(0,-0.6,0); armR.position.copy(armL.position);
      legL.position.set(0,-0.7,0); legR.position.copy(legL.position);
      aL.position.set(-0.9, 2.2, 0); aR.position.set( 0.9, 2.2, 0);
      lL.position.set(-0.3, 1.4, 0); lR.position.set( 0.3, 1.4, 0);
      aL.add(armL); aR.add(armR); lL.add(legL); lR.add(legR);
      root.add(aL,aR,lL,lR);
      root.userData.limbs = { aL, aR, lL, lR };
      return root;
    }

    export function AvatarFactory(THREE){
      const materials = {
        skin:  new THREE.MeshStandardMaterial({ color: 0xffe0bd }),
        limb:  new THREE.MeshStandardMaterial({ color: 0x888888 }),
        black: new THREE.MeshStandardMaterial({ color: 0x111111 }),
        white: new THREE.MeshStandardMaterial({ color: 0xffffff }),
      };
      return {
        create(){
          const avatar = createAvatarMesh(THREE, materials);
          return avatar;
        }
      };
    }

    // Hareket/animasyon mantığı — DEĞİŞMEDİ
    export function updateAvatar(THREE, dt, avatar, keys, camera, controls, helpers){
      if(!avatar) return;
      const { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock } = helpers;
      const AVATAR_SIZE = 2;

      const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

      const moveX = (keys.d?1:0) + (keys.a?-1:0);
      const moveZ = (keys.s?1:0) + (keys.w?-1:0);
      const move = new THREE.Vector3().addScaledVector(forward, -moveZ).addScaledVector(right, moveX);
      if (move.lengthSq()>0) move.normalize();

      avatar.userData.vel ??= new THREE.Vector3(0,0,0);
      const vel = avatar.userData.vel;
      const speed = 18, gravity = 22, jumpSpeed = 8.5, friction = 10;
      vel.x += (move.x*speed - vel.x)*Math.min(1, dt*8);
      vel.z += (move.z*speed - vel.z)*Math.min(1, dt*8);
      if (move.lengthSq()===0){ const damp=Math.max(0,1-friction*dt); vel.x*=damp; vel.z*=damp; }

      const gY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      const onGround = Math.abs(avatar.position.y - gY) < 0.01;
      if (onGround && keys.space) vel.y = jumpSpeed; else if (!onGround) vel.y -= gravity*dt; else vel.y = 0;

      const prev = avatar.position.clone();
      avatar.position.x += vel.x*dt; avatar.position.y = Math.max(avatar.position.y + vel.y*dt, AVATAR_SIZE/2); avatar.position.z += vel.z*dt;

      const minX = -planeSize/2 + AVATAR_SIZE/2, maxX = planeSize/2 - AVATAR_SIZE/2, minZ = -planeSize/2 + AVATAR_SIZE/2, maxZ = planeSize/2 - AVATAR_SIZE/2;
      avatar.position.x = Math.min(Math.max(avatar.position.x, minX), maxX);
      avatar.position.z = Math.min(Math.max(avatar.position.z, minZ), maxZ);

      if (insideStageXZ(avatar.position.x, avatar.position.z) && (avatar.position.y - AVATAR_SIZE/2) < (stageTopY + 0.01)){
        avatar.position.x = prev.x; avatar.position.z = prev.z; vel.x = 0; vel.z = 0;
      }

      if (typeof roomBlock === 'function'){
        roomBlock(avatar.position, prev, AVATAR_SIZE/2);
      }

      const nGY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      if (avatar.position.y < nGY){ avatar.position.y = nGY; vel.y = 0; }

      if (vel.lengthSq()>0.0001){ const dirY = Math.atan2(vel.x, vel.z); if(!Number.isNaN(dirY)) avatar.rotation.y = dirY; }

      // Animasyon stabilitesi — aynı
      avatar.userData.animBlend ??= 0;            
      avatar.userData.swingTime ??= 0;            
      const speed2D = Math.hypot(vel.x, vel.z);
      const targetRun = Math.min(1, speed2D / speed);
      const blendK = 12; 
      avatar.userData.animBlend += (targetRun - avatar.userData.animBlend) * Math.min(1, dt * blendK);
      if (avatar.userData.animBlend < 0.05) avatar.userData.swingTime = 0; 
      const freq = THREE.MathUtils.lerp(2.0, 6.0, avatar.userData.animBlend);
      avatar.userData.swingTime += dt * freq;
      const amp  = THREE.MathUtils.lerp(0.1, 0.6, avatar.userData.animBlend);
      const s = Math.sin(avatar.userData.swingTime);
      const { aL, aR, lL, lR } = avatar.userData.limbs;
      aL.rotation.x =  s * amp;
      aR.rotation.x = -s * amp;
      lL.rotation.x = -s * amp;
      lR.rotation.x =  s * amp;
      if(!onGround){ aL.rotation.x += 0.6; aR.rotation.x += 0.6; }

      const desiredTarget = avatar.position.clone(); const deltaTarget = desiredTarget.clone().sub(controls.target); camera.position.add(deltaTarget); controls.target.copy(desiredTarget);
    }
  </script>

  <!-- Main -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'orbit';

    // Inline dynamic importer — avoids bare specifiers
    async function importById(id){
      const el = document.getElementById(id);
      if(!el) throw new Error(`Modül bulunamadı: ${id}`);
      const code = el.textContent;
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      try { return await import(url); } finally { URL.revokeObjectURL(url); }
    }

    const utils                = await importById('mod-utils');
    const { createSceneSetup } = await importById('mod-scene');
    const { createInput }      = await importById('mod-input');
    const { createGarden }     = await importById('mod-garden');
    const { createGlassRoom }  = await importById('mod-glassroom');
    const { AvatarFactory, updateAvatar } = await importById('mod-entities');

    const hud = document.getElementById('hud');
    const nameTag = document.getElementById('nameTag');

    const { scene, camera, renderer, controls } = createSceneSetup(THREE, OrbitControls);
    const keys = createInput();

    const { planeSize, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt } = createGarden(THREE, scene);
    const stageTopY = stage.position.y + STAGE_H/2;

    // Camlı oda: sahne ile aynı boyut; haritanın en sağ kenarı
    const roomPos = new THREE.Vector3( planeSize/2 - STAGE_W/2, 0, 0 );
    const { room: glassRoom, block: roomBlock } = createGlassRoom(THREE, scene, { w: STAGE_W, d: STAGE_D, position: roomPos });

    // Avatar: factory ile oluştur
    const avatarFactory = AvatarFactory(THREE);
    const avatar = avatarFactory.create();
    scene.add(avatar);

    // Spawn: odanın içinde, sahneye (batıya) dönük
    avatar.position.set(roomPos.x, 1, roomPos.z);
    avatar.rotation.y = -Math.PI/2; // sahneye bakış

    // Kamera: sahneye doğru baksın
    camera.position.set(avatar.position.x + 12, avatar.position.y + 8, avatar.position.z + 0);
    controls.target.copy(avatar.position);

    function updateNameTag(){
      const pos = avatar.position.clone();
      pos.y += 3.2; // kafanın biraz üstü
      pos.project(camera);
      const out = (Math.abs(pos.x) > 1 || Math.abs(pos.y) > 1 || pos.z > 1);
      if(out){ nameTag.classList.add('hidden'); return; }
      nameTag.classList.remove('hidden');
      const x = (pos.x * 0.5 + 0.5) * innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * innerHeight;
      nameTag.style.transform = `translate(-50%, -100%) translate(${x}px, ${y}px)`;
    }

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      updateAvatar(THREE, dt, avatar, keys, camera, controls, { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock });
      controls.update();
      renderer.render(scene, camera);

      // HUD
      const heading = ((utils.deg(avatar.rotation.y) % 360) + 360) % 360;
      hud.textContent = `x: ${utils.fmt(avatar.position.x)}\ny: ${utils.fmt(avatar.position.y)}\nz: ${utils.fmt(avatar.position.z)}\nrotY: ${heading.toFixed(1)}°`;
      updateNameTag();
    }
    animate();
  </script>
</body>
</html>
