<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Garden – Tek Dosyada Modüler (Three.js + Box‑Man)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    .hint { position: fixed; left: 12px; top: 12px; color: #fff; font: 14px/1.4 system-ui, sans-serif; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px; user-select: none; -webkit-user-select: none; z-index: 2; }
  </style>
</head>
<body>
  <div class="hint">W-A-S-D: kamera göreli hareket · Space: zıpla · Fare: kamerayı çevir</div>

  <!-- import map: three + orbit -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "orbit": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <!-- Avatar Module (inline) -->
  <script type="module" id="mod-avatar">
    export function createBoxMan({ THREE, scene, startY = 1, start = { x:0, z:20 } }) {
      const skin = new THREE.MeshStandardMaterial({ color: 0xffe0bd });
      const limb = new THREE.MeshStandardMaterial({ color: 0x888888 });
      const black = new THREE.MeshStandardMaterial({ color: 0x111111 });
      const white = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const gBox = (x,y,z,m)=>{ const mesh=new THREE.Mesh(new THREE.BoxGeometry(x,y,z), m); mesh.castShadow=true; return mesh; };

      const root = new THREE.Group();
      const torso = gBox(1.2, 1.6, 0.6, skin); torso.position.y = 1.6; root.add(torso);
      const head  = gBox(0.9, 0.9, 0.9, skin); head.position.y  = 2.65; root.add(head);
      // yüz
      const face = new THREE.Group(); face.position.set(0, 2.65, 0.455);
      const eyeW_L = gBox(0.22, 0.18, 0.02, white); eyeW_L.position.set(-0.22, 0.08, 0);
      const eyeW_R = eyeW_L.clone(); eyeW_R.position.x *= -1;
      const eye_L = gBox(0.08, 0.08, 0.03, black); eye_L.position.set(-0.22, 0.08, 0.02);
      const eye_R = eye_L.clone(); eye_R.position.x *= -1;
      const brow_L = gBox(0.28, 0.05, 0.03, black); brow_L.position.set(-0.22, 0.2, 0.01);
      const brow_R = brow_L.clone(); brow_R.position.x *= -1;
      face.add(eyeW_L, eyeW_R, eye_L, eye_R, brow_L, brow_R); root.add(face);

      const armL = gBox(0.35, 1.2, 0.35, limb), armR = gBox(0.35, 1.2, 0.35, limb);
      const legL = gBox(0.45, 1.4, 0.45, limb), legR = gBox(0.45, 1.4, 0.45, limb);
      armL.position.set(0, -0.6, 0); armR.position.copy(armL.position);
      legL.position.set(0, -0.7, 0); legR.position.copy(legL.position);
      const aL = new THREE.Group(), aR = new THREE.Group(), lL = new THREE.Group(), lR = new THREE.Group();
      aL.position.set(-0.9, 2.2, 0); aR.position.set( 0.9, 2.2, 0);
      lL.position.set(-0.3, 1.4, 0); lR.position.set( 0.3, 1.4, 0);
      aL.add(armL); aR.add(armR); lL.add(legL); lR.add(legR);
      root.add(aL, aR, lL, lR);

      root.position.set(start.x, startY, start.z);
      scene.add(root);

      const swing = { aL, aR, lL, lR, t:0 };
      function update(dt, { vel, onGround }){
        swing.t += dt; const speed2D = Math.hypot(vel.x, vel.z);
        const freq = THREE.MathUtils.lerp(2.0, 6.0, Math.min(1, speed2D/10));
        const amp  = THREE.MathUtils.lerp(0.1, 0.6, Math.min(1, speed2D/10));
        const s = Math.sin(swing.t * freq);
        swing.aL.rotation.x =  s * amp;
        swing.aR.rotation.x = -s * amp;
        swing.lL.rotation.x = -s * amp;
        swing.lR.rotation.x =  s * amp;
        if (!onGround) { swing.aL.rotation.x += 0.6; swing.aR.rotation.x += 0.6; }
      }

      return { group: root, update };
    }
  </script>

  <!-- Stage Module (inline) -->
  <script type="module" id="mod-stage">
    export function createStage({ THREE, scene, planeSize=200, w=30, d=20, h=10 }){
      const mat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.8 });
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
      mesh.castShadow = true; mesh.receiveShadow = true;
      mesh.position.set(-planeSize/2 + w/2, h/2, -planeSize/2 + d/2);
      scene.add(mesh);
      return { mesh, w, d, h };
    }
  </script>

  <!-- Garden Module (inline) -->
  <script type="module" id="mod-garden">
    export function createGarden({ THREE, scene, planeSize=200 }){
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(planeSize, planeSize),
        new THREE.MeshLambertMaterial({ color: 0x2faa2f })
      );
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);
      return { ground, planeSize };
    }
    export function makeCollisionHelpers({ THREE, stage, planeSize, avatarHalf=1 }){
      const insideStageXZ = (x,z)=>{
        const sxMin = stage.mesh.position.x - stage.w/2 - avatarHalf,
              sxMax = stage.mesh.position.x + stage.w/2 + avatarHalf,
              szMin = stage.mesh.position.z - stage.d/2 - avatarHalf,
              szMax = stage.mesh.position.z + stage.d/2 + avatarHalf;
        return x>=sxMin && x<=sxMax && z>=szMin && z<=szMax;
      };
      const groundYAt = (x,z)=> insideStageXZ(x,z) ? 9999 : 0;
      return { insideStageXZ, groundYAt };
    }
  </script>

  <!-- App Root (only dynamic-import inline modules via Blob URLs) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'orbit';

    // Utility: import inline module by creating a blob URL (no bare specifier!)
    async function importById(id){
      const el = document.getElementById(id);
      const code = el.textContent;
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      try { return await import(url); } finally { URL.revokeObjectURL(url); }
    }

    const AvatarMod = await importById('mod-avatar');
    const StageMod  = await importById('mod-stage');
    const GardenMod = await importById('mod-garden');

    // --- Scene Setup ---
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0x87b7ff);
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000); camera.position.set(0,10,16);
    const renderer = new THREE.WebGLRenderer({ antialias:true }); renderer.setSize(innerWidth, innerHeight); renderer.shadowMap.enabled = true; document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enablePan = false;
    controls.minDistance = 6; controls.maxDistance = 40; controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 2, 0);
    // OrbitControls keyboard off (WASD bizde)
    controls.enableKeys = false; controls.keys = {}; controls.keyPanSpeed = 0;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(60,100,40); dl.castShadow = true; dl.shadow.mapSize.set(2048,2048); scene.add(dl);

    // Garden + Stage
    const garden = GardenMod.createGarden({ THREE, scene, planeSize:200 });
    const stage  = StageMod.createStage({ THREE, scene, planeSize: garden.planeSize, w:30, d:20, h:10 });
    const { insideStageXZ, groundYAt } = GardenMod.makeCollisionHelpers({ THREE, stage, planeSize: garden.planeSize, avatarHalf: 1 });

    // Avatar
    const avatar = AvatarMod.createBoxMan({ THREE, scene, startY: 1, start:{x:0,z:20} });

    // Input
    const keys = { w:false,a:false,s:false,d:false,space:false };
    const mapKey = (e)=>{ const k=e.key; if(k===' '||k==='Spacebar') return 'space'; const low=(k||'').toLowerCase(); return low==='space'?'space':low; };
    addEventListener('keydown',e=>{const k=mapKey(e); if(k in keys){keys[k]=true; if(k==='space') e.preventDefault();}});
    addEventListener('keyup',  e=>{const k=mapKey(e); if(k in keys){keys[k]=false; if(k==='space') e.preventDefault();}});

    // Physics
    const AVATAR_SIZE = 2, speed=18, friction=10, jumpSpeed=8.5, gravity=22;
    const bounds = { minX:-garden.planeSize/2+AVATAR_SIZE/2, maxX:garden.planeSize/2-AVATAR_SIZE/2, minZ:-garden.planeSize/2+AVATAR_SIZE/2, maxZ:garden.planeSize/2-AVATAR_SIZE/2 };
    const vel = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0), fwd=new THREE.Vector3(), right=new THREE.Vector3();

    // Loop
    const clock = new THREE.Clock();
    function tick(dt){
      // camera-relative axes
      camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
      right.crossVectors(fwd, up).normalize();

      // input → desired vel
      let mx=0,mz=0; if(keys.w)mz-=1; if(keys.s)mz+=1; if(keys.a)mx-=1; if(keys.d)mx+=1; const mag=Math.hypot(mx,mz); if(mag>0){mx/=mag;mz/=mag;}
      const desired = mag>0 ? fwd.clone().multiplyScalar(-mz).add(right.clone().multiplyScalar(mx)).multiplyScalar(speed) : new THREE.Vector3();
      vel.x += (desired.x-vel.x)*Math.min(1, dt*8); vel.z += (desired.z-vel.z)*Math.min(1, dt*8);
      if(mag===0){ const damp=Math.max(0,1-friction*dt); vel.x*=damp; vel.z*=damp; }

      // gravity/jump
      const gY = groundYAt(avatar.group.position.x, avatar.group.position.z) + AVATAR_SIZE/2;
      const onGround = Math.abs(avatar.group.position.y - gY) < 0.01;
      if(onGround && keys.space) vel.y = jumpSpeed; else if(!onGround) vel.y -= gravity*dt; else vel.y = 0;

      const prev = avatar.group.position.clone();
      avatar.group.position.x += vel.x*dt;
      avatar.group.position.y = Math.max(avatar.group.position.y + vel.y*dt, AVATAR_SIZE/2);
      avatar.group.position.z += vel.z*dt;

      // bounds & stage block
      avatar.group.position.x = Math.min(Math.max(avatar.group.position.x, bounds.minX), bounds.maxX);
      avatar.group.position.z = Math.min(Math.max(avatar.group.position.z, bounds.minZ), bounds.maxZ);
      if(insideStageXZ(avatar.group.position.x, avatar.group.position.z)){
        avatar.group.position.copy(prev); vel.x = 0; vel.z = 0;
      }

      const nGY = groundYAt(avatar.group.position.x, avatar.group.position.z) + AVATAR_SIZE/2;
      if(avatar.group.position.y < nGY){ avatar.group.position.y = nGY; vel.y = 0; }

      // face move dir
      const dirY = Math.atan2(vel.x, vel.z); if(!Number.isNaN(dirY)) avatar.group.rotation.y = dirY;

      // avatar anim
      avatar.update(dt, { vel, onGround });
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      tick(dt);

      // keep camera distance (no auto-zoom)
      const desiredTarget = avatar.group.position.clone();
      const delta = desiredTarget.clone().sub(controls.target);
      camera.position.add(delta);
      controls.target.copy(desiredTarget);

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
