<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>Garden – Modular Single File (Three.js + Box‑Man + Glass Room)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    .hud { position: fixed; left: 12px; top: 12px; color: #fff; font: 14px/1.4 system-ui, sans-serif; background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px; user-select: none; z-index: 3; white-space: pre; }
    .name-tag { position: fixed; left: 0; top: 0; transform: translate(-50%, -100%); padding: 4px 8px; border-radius: 6px; font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; color: #EAF2FF; background: rgba(18,18,24,.78); border: 1px solid rgba(255,255,255,.15); box-shadow: 0 2px 8px rgba(0,0,0,.35); pointer-events: none; z-index: 4; white-space: nowrap; }
    .name-tag.hidden { display: none; }
  </style>
</head>
<body>
  <!-- HUD: koordinatlar + yön -->
  <div class="hud" id="hud">—</div>
  <!-- Avatar etiketi -->
  <div class="name-tag" id="nameTag">macaris64</div>

  <!-- import map: three + orbit -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
      "orbit": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <!-- Utils -->
  <script type="module" id="mod-utils">
    export const deg = (rad)=> (rad * 180 / Math.PI);
    export const fmt = (n)=> Number(n).toFixed(2);
    export function lerp(a,b,t){ return a + (b-a)*t; }
    export function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  </script>

  <!-- Scene Setup (amb + sun referansları) -->
  <script type="module" id="mod-scene">
    export function createSceneSetup(THREE, OrbitControls){
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87b7ff);

      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 8000);
      camera.position.set(0, 10, 16);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08; controls.enablePan = false;
      controls.minDistance = 6; controls.maxDistance = 100; controls.maxPolarAngle = Math.PI * 0.49;
      controls.enableKeys = false; controls.keys = {}; controls.keyPanSpeed = 0;
      controls.target.set(0, 2, 0);

      const amb = new THREE.AmbientLight(0xffffff, 0.5); scene.add(amb);
      const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(60,100,40); sun.castShadow = true; sun.shadow.mapSize.set(2048,2048); scene.add(sun);

      addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
      });

      return { scene, camera, renderer, controls, amb, sun };
    }
  </script>

  <!-- Input -->
  <script type="module" id="mod-input">
    export function createInput(){
      const keys = { w:false, a:false, s:false, d:false, space:false };
      const mapKey = (e)=>{ const k=e.key; if(k===' '||k==='Spacebar') return 'space'; const low=(k||'').toLowerCase(); return low==='space'?'space':low; };
      addEventListener('keydown',e=>{const k=mapKey(e); if(k in keys){keys[k]=true; if(k==='space') e.preventDefault();}});
      addEventListener('keyup',  e=>{const k=mapKey(e); if(k in keys){keys[k]=false; if(k==='space') e.preventDefault();}});
      return keys;
    }
  </script>

  <!-- Garden (CIRCULAR ground + stage + side board w/ collision) -->
  <script type="module" id="mod-garden">
    export function createGarden(THREE, scene){
      const planeSize = 400; // sahne ölçeği referansı

      // Dairesel zemin: silindirin başladığı yerden biraz küçük (curtain r ~ planeSize*0.8)
      const groundR = planeSize * 0.78; // elips istenirse x/z farklı ölçeklenebilir
      const circle = new THREE.Mesh(
        new THREE.CircleGeometry(groundR, 128),
        new THREE.MeshLambertMaterial({ color: 0x2faa2f })
      );
      circle.rotation.x = -Math.PI/2; circle.receiveShadow = true; scene.add(circle);

      // Sahne (X sabit solda, Z ortada)
      const STAGE_W = 90, STAGE_D = 90, STAGE_H = 15;
      const stageMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.8 });
      const stage = new THREE.Mesh(new THREE.BoxGeometry(STAGE_W, STAGE_H, STAGE_D), stageMat);
      stage.castShadow = true; stage.receiveShadow = true;
      stage.position.set(-planeSize/2 + STAGE_W/2, STAGE_H/2, 0);
      scene.add(stage);

      // *** Sunum tahtası (kare) — sahnenin önünün hemen sağı ***
      const boardSize = 80;                   // kare kenar
      const boardX = -110;                    // düzlem X sabit
      const boardZMin = -130, boardZMax = -50;// Z aralığı
      const boardZCenter = (boardZMin + boardZMax) * 0.5; // -90
      const boardYCenter = boardSize * 0.5;   // 40 (taban 0)
      const board = new THREE.Mesh(
        new THREE.PlaneGeometry(boardSize, boardSize),
        new THREE.MeshStandardMaterial({ color: 0xffffff, metalness:0.0, roughness:0.25, side: THREE.DoubleSide })
      );
      board.position.set(boardX, boardYCenter, boardZCenter);
      board.rotation.y = -Math.PI/2; // doğu
      scene.add(board);

      // --- Sunum tahtası ÇARPIŞMA ---
      function boardBlock(pos, prev, half = 1){
        const yMin = 0, yMax = boardSize;
        const zMin = boardZMin, zMax = boardZMax;
        const withinZ = (pos.z > zMin - half && pos.z < zMax + half) || (prev.z > zMin - half && prev.z < zMax + half);
        const withinY = (pos.y - half < yMax && pos.y + half > yMin) || (prev.y - half < yMax && prev.y + half > yMin);
        if (!withinZ || !withinY) return;
        const sidePrev = Math.sign(prev.x - boardX);
        const sideNow  = Math.sign(pos.x  - boardX);
        if (sidePrev === 0 && sideNow === 0) return;
        if (sidePrev === 0 && sideNow !== 0){ pos.x = boardX + (sideNow > 0 ? half : -half); return; }
        if (sidePrev !== 0 && sideNow !== 0 && sidePrev !== sideNow){ pos.x = prev.x; return; }
      }

      // Dikdörtgen platform çarpışması (sahneden aşağı düşmeyi önleme)
      function insideStageXZ(x, z, half=1){
        const sxMin = stage.position.x - STAGE_W/2 - half,
              sxMax = stage.position.x + STAGE_W/2 + half,
              szMin = stage.position.z - STAGE_D/2 - half,
              szMax = stage.position.z + STAGE_D/2 + half;
        return x>=sxMin && x<=sxMax && z>=szMin && z<=szMax;
      }

      // Eliptik/dairesel zemin fonksiyonu
      const a = groundR, b = groundR; // elips istiyorsak b'yi farklı seçebiliriz
      function insideEllipse(x, z){
        // Merkez (0,0) varsayıldı. Farklı merkez için (x-cx,z-cz)
        const v = (x*x)/(a*a) + (z*z)/(b*b);
        return v <= 1.0;
      }

      // Avatar için yer yüksekliği: elips içindeyse 0, değilse "uçurum"
      const groundYAt = (x,z,half=1)=> {
        // Sahnenin üstünden geçişi önleyen mevcut kuralı koruyoruz
        if (insideStageXZ(x,z,half)) return 9999;
        return insideEllipse(x,z) ? 0 : 9999;
      };

      return { ground: circle, planeSize, groundR, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt, boardBlock };
    }
  </script>

  <!-- Glass Room (camlı oda) – Kapı BATI -->
  <script type="module" id="mod-glassroom">
    export function createGlassRoom(THREE, scene, { w, d, position, doorRatio = 0.35 }){
      const baseH  = 2.6;      // alt bant
      const upperH = 15.0;     // üst bant
      const h = baseH + upperH;
      const t = 0.25;

      const group = new THREE.Group();
      const matPillar = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.6, roughness: 0.5 });
      const matGlass  = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, metalness: 0.0, roughness: 0.15 });
      const matFloor  = new THREE.MeshStandardMaterial({ color: 0x303030 });

      const floor = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matFloor);
      floor.position.y = 0; floor.receiveShadow = true; group.add(floor);

      const doorW = Math.max(1.2, d * doorRatio);
      const segZ = Math.max(0, (d - doorW) / 2);
      const northBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); northBase.position.set(0, baseH/2, -d/2); group.add(northBase);
      const southBase = new THREE.Mesh(new THREE.BoxGeometry(w, baseH, t), matPillar); southBase.position.set(0, baseH/2,  d/2); group.add(southBase);
      const eastBase  = new THREE.Mesh(new THREE.BoxGeometry(d, baseH, t), matPillar); eastBase.rotation.y = Math.PI/2; eastBase.position.set( w/2, baseH/2, 0); group.add(eastBase);
      if (segZ > 0) {
        const westBaseL = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseL.rotation.y = Math.PI/2; westBaseL.position.set(-w/2, baseH/2, -(doorW/2 + segZ/2)); group.add(westBaseL);
        const westBaseR = new THREE.Mesh(new THREE.BoxGeometry(segZ, baseH, t), matPillar); westBaseR.rotation.y = Math.PI/2; westBaseR.position.set(-w/2, baseH/2,  (doorW/2 + segZ/2)); group.add(westBaseR);
      }

      const colW=2.4, panelW=1.2, cell=colW+panelW; const yUpperMid = baseH + upperH/2;
      function buildUpperStrip({ along, L, fixedVal, isWestDoor=false }){
        const count = Math.ceil(L / cell);
        for (let i=0;i<count;i++){
          const base = -L/2 + i*cell;
          const colLen = Math.min(colW, L - i*cell);
          if (colLen > 0){
            const col = new THREE.Mesh(along==='x'? new THREE.BoxGeometry(colLen, upperH, t) : new THREE.BoxGeometry(t, upperH, colLen), matPillar);
            if (along==='x') col.position.set(base + colLen/2, yUpperMid, fixedVal); else col.position.set(fixedVal, yUpperMid, base + colLen/2);
            if (!(isWestDoor && Math.abs(col.position.z) <= doorW/2)) group.add(col);
          }
          const panLen = Math.min(panelW, L - (i*cell + colLen));
          if (panLen > 0){
            const pan = new THREE.Mesh(along==='x'? new THREE.BoxGeometry(panLen, upperH, t) : new THREE.BoxGeometry(t, upperH, panLen), matGlass);
            if (along==='x') pan.position.set(base + colLen + panLen/2, yUpperMid, fixedVal); else pan.position.set(fixedVal, yUpperMid, base + colLen + panLen/2);
            if (!(isWestDoor && Math.abs(pan.position.z) <= doorW/2)) group.add(pan);
          }
        }
      }
      buildUpperStrip({ along:'x', L:w, fixedVal:-d/2, isWestDoor:false });
      buildUpperStrip({ along:'x', L:w, fixedVal: d/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal: w/2, isWestDoor:false });
      buildUpperStrip({ along:'z', L:d, fixedVal:-w/2, isWestDoor:true  });

      const roof = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), matGlass);
      roof.position.set(0, h + t/2, 0); group.add(roof);

      group.position.copy(position);
      scene.add(group);

      const hx = w/2, hz = d/2; const ixMin=-hx, ixMax=hx, izMin=-hz, izMax=hz;
      function isInsideInner(lx, lz, half){ return (lx > ixMin + half && lx < ixMax - half && lz > izMin + half && lz < izMax - half); }
      function roomBlock(pos, prev, half = 1){
        const lx=pos.x-position.x, lz=pos.z-position.z, lpx=prev.x-position.x, lpz=prev.z-position.z;
        const prevInside=isInsideInner(lpx,lpz,half), nowInside=isInsideInner(lx,lz,half);
        const doorW = Math.max(1.2, d * 0.35);
        const inDoorZ = Math.abs(lz) <= doorW/2; const westInnerPlane = ixMin + half;
        const crossingWestOut=(lpx>=westInnerPlane && lx<westInnerPlane), crossingWestIn=(lpx<=westInnerPlane && lx>westInnerPlane);
        if (prevInside && !nowInside){ const throughDoor=crossingWestOut && inDoorZ; if(!throughDoor){ pos.x=prev.x; pos.z=prev.z; return; } }
        if (!prevInside && nowInside){ const throughDoor=crossingWestIn  && inDoorZ; if(!throughDoor){ pos.x=prev.x; pos.z=prev.z; return; } }
        if (prevInside && nowInside){
          pos.x = Math.min(Math.max(pos.x, position.x + ixMin + half), position.x + ixMax - half);
          pos.z = Math.min(Math.max(pos.z, position.z + izMin + half), position.z + izMax - half);
        }
      }
      return { room: group, height: h, block: roomBlock };
    }
  </script>

  <!-- NFT / Sertifika Binası (kapı KUZEY, diğer 3 duvarda 3’er çerçeve) -->
  <script type="module" id="mod-nft-building">
    export function createNftBuilding(THREE, scene, {
      w = 60, d = 40, h = 22,
      position = new THREE.Vector3(5, 0, 135),
      doorRatio = 0.35,
    } = {}){
      const group = new THREE.Group();
      const purple = new THREE.MeshStandardMaterial({ color: 0x7a3cf6, metalness: 0.35, roughness: 0.6 });
      const black  = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.5, roughness: 0.4 });
      const whiteM = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.2, side: THREE.DoubleSide });
      const t = 0.3; // duvar kalınlığı

      const floor = new THREE.Mesh(new THREE.BoxGeometry(w, t, d), purple);
      floor.position.y = 0; floor.receiveShadow = true; group.add(floor);

      const doorW = Math.max(2.0, w * doorRatio);
      const doorH = Math.min(3.2, h * 0.5);
      const hx = w/2, hz = d/2;

      const segW = Math.max(0, (w - doorW)/2);
      if (segW > 0){
        const northL = new THREE.Mesh(new THREE.BoxGeometry(segW, h, t), purple); northL.position.set(-(doorW/2 + segW/2), h/2, -hz); group.add(northL);
        const northR = new THREE.Mesh(new THREE.BoxGeometry(segW, h, t), purple); northR.position.set( (doorW/2 + segW/2), h/2, -hz); group.add(northR);
      }
      const south = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), purple); south.position.set(0, h/2,  hz); group.add(south);
      const west  = new THREE.Mesh(new THREE.BoxGeometry(d, h, t), purple); west.rotation.y = Math.PI/2;  west.position.set(-hx, h/2, 0); group.add(west);
      const east  = new THREE.Mesh(new THREE.BoxGeometry(d, h, t), purple); east.rotation.y = Math.PI/2;   east.position.set( hx, h/2, 0); group.add(east);

      const fw = 8, fh = 6, gap = 3, inset = t/2 + 0.02, border = 0.4, depth = 0.2;
      function makeFrame(){
        const panel = new THREE.Mesh(new THREE.PlaneGeometry(fw-2*border, fh-2*border), whiteM);
        const barH  = new THREE.BoxGeometry(fw, border, depth);
        const barV  = new THREE.BoxGeometry(border, fh, depth);
        const top = new THREE.Mesh(barH, black), bot=new THREE.Mesh(barH, black), lef=new THREE.Mesh(barV, black), rig=new THREE.Mesh(barV, black);
        top.position.set(0,  (fh-border)/2, 0); bot.position.set(0, -(fh-border)/2, 0);
        lef.position.set(-(fw-border)/2, 0, 0); rig.position.set( (fw-border)/2, 0, 0);
        const g = new THREE.Group(); g.add(panel, top, bot, lef, rig); return g;
      }
      function addTriple(which){
        const totalW = 3*fw + 2*gap; const y = h*0.55;
        for(let i=0;i<3;i++){
          const g = makeFrame();
          const lx = -totalW/2 + i*(fw+gap) + fw/2;
          if(which==='south'){ g.rotation.y = Math.PI; g.position.set(lx, y,  hz - inset); }
          if(which==='west') { g.rotation.y =  Math.PI/2; g.position.set(-hx + inset, y, lx); }
          if(which==='east') { g.rotation.y = -Math.PI/2; g.position.set( hx - inset, y, lx); }
          group.add(g);
        }
      }
      addTriple('south');
      addTriple('west');
      addTriple('east');

      group.position.copy(position);
      scene.add(group);

      const ixMin=-hx, ixMax=hx, izMin=-hz, izMax=hz;
      function isInside(lx,lz,half){ return (lx > ixMin + half && lx < ixMax - half && lz > izMin + half && lz < izMax - half); }
      function buildingBlock(pos, prev, half=1){
        const lx=pos.x-position.x, lz=pos.z-position.z, lpx=prev.x-position.x, lpz=prev.z-position.z;
        const prevInside=isInside(lpx,lpz,half), nowInside=isInside(lx,lz,half);
        const inDoorX = Math.abs(lx) <= doorW/2; const inDoorY = (pos.y - half) <= doorH;
        const northPlane = izMin + half;
        const crossingNorthOut=(lpz >= northPlane && lz <  northPlane);
        const crossingNorthIn =(lpz <= northPlane && lz >  northPlane);

        if (prevInside && !nowInside){
          const through = crossingNorthOut && inDoorX && inDoorY;
          if(!through){ pos.x=prev.x; pos.z=prev.z; return; }
        }
        if (!prevInside && nowInside){
          const through = crossingNorthIn && inDoorX && inDoorY;
          if(!through){ pos.x=prev.x; pos.z=prev.z; return; }
        }
        if (prevInside && nowInside){
          pos.x = Math.min(Math.max(pos.x, position.x + ixMin + half), position.x + ixMax - half);
          pos.z = Math.min(Math.max(pos.z, position.z + izMin + half), position.z + izMax - half);
        }
      }

      return { building: group, block: buildingBlock, size:{w,d,h}, door:{w:doorW,h:doorH} };
    }
  </script>

  <!-- Avatar Factory + Animator -->
  <script type="module" id="mod-entities">
    export function createAvatarMesh(THREE, materials){
      const { skin, limb, black, white } = materials;
      const gBox = (x,y,z,m)=>{ const mesh=new THREE.Mesh(new THREE.BoxGeometry(x,y,z), m); mesh.castShadow=true; return mesh; };
      const root  = new THREE.Group();
      const torso = gBox(1.2, 1.6, 0.6, skin); torso.position.y = 1.6; root.add(torso);
      const head  = gBox(0.9, 0.9, 0.9, skin); head.position.y  = 2.65; root.add(head);
      const face = new THREE.Group(); face.position.set(0, 2.65, 0.455);
      const eyeW_L = gBox(0.22,0.18,0.02, white); eyeW_L.position.set(-0.22,0.08,0);
      const eyeW_R = eyeW_L.clone(); eyeW_R.position.x *= -1;
      const eye_L  = gBox(0.08,0.08,0.03, black); eye_L.position.set(-0.22,0.08,0.02);
      const eye_R  = eye_L.clone(); eye_R.position.x *= -1;
      const brow_L = gBox(0.28,0.05,0.03, black); brow_L.position.set(-0.22,0.2,0.01);
      const brow_R = brow_L.clone(); brow_R.position.x *= -1;
      face.add(eyeW_L, eyeW_R, eye_L, eye_R, brow_L, brow_R); root.add(face);
      const arm = gBox(0.35, 1.2, 0.35, limb), leg = gBox(0.45, 1.4, 0.45, limb);
      const aL = new THREE.Group(), aR = new THREE.Group(), lL = new THREE.Group(), lR = new THREE.Group();
      const armL = arm.clone(), armR = arm.clone(), legL = leg.clone(), legR = leg.clone();
      armL.position.set(0,-0.6,0); armR.position.copy(armL.position);
      legL.position.set(0,-0.7,0); legR.position.copy(legL.position);
      aL.position.set(-0.9, 2.2, 0); aR.position.set( 0.9, 2.2, 0);
      lL.position.set(-0.3, 1.4, 0); lR.position.set( 0.3, 1.4, 0);
      aL.add(armL); aR.add(armR); lL.add(legL); lR.add(legR);
      root.add(aL,aR,lL,lR);
      root.userData.limbs = { aL, aR, lL, lR };
      return root;
    }

    export function AvatarFactory(THREE){
      const materials = {
        skin:  new THREE.MeshStandardMaterial({ color: 0xffe0bd }),
        limb:  new THREE.MeshStandardMaterial({ color: 0x888888 }),
        black: new THREE.MeshStandardMaterial({ color: 0x111111 }),
        white: new THREE.MeshStandardMaterial({ color: 0xffffff }),
      };
      return {
        create(){
          const avatar = createAvatarMesh(THREE, materials);
          return avatar;
        }
      };
    }

    // Hareket/animasyon mantığı — DEĞİŞMEDİ (yalnızca opsiyonel engeller eklendi)
    export function updateAvatar(THREE, dt, avatar, keys, camera, controls, helpers){
      if(!avatar) return;
      const { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock, buildingBlock, boardBlock } = helpers;
      const AVATAR_SIZE = 2;

      const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y=0; forward.normalize();
      const right   = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

      const moveX = (keys.d?1:0) + (keys.a?-1:0);
      const moveZ = (keys.s?1:0) + (keys.w?-1:0);
      const move = new THREE.Vector3().addScaledVector(forward, -moveZ).addScaledVector(right, moveX);
      if (move.lengthSq()>0) move.normalize();

      avatar.userData.vel ??= new THREE.Vector3(0,0,0);
      const vel = avatar.userData.vel;
      const speed = 18, gravity = 22, jumpSpeed = 8.5, friction = 10;
      vel.x += (move.x*speed - vel.x)*Math.min(1, dt*8);
      vel.z += (move.z*speed - vel.z)*Math.min(1, dt*8);
      if (move.lengthSq()===0){ const damp=Math.max(0,1-friction*dt); vel.x*=damp; vel.z*=damp; }

      const gY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      const onGround = Math.abs(avatar.position.y - gY) < 0.01;
      if (onGround && keys.space) vel.y = jumpSpeed; else if (!onGround) vel.y -= gravity*dt; else vel.y = 0;

      const prev = avatar.position.clone();
      avatar.position.x += vel.x*dt; avatar.position.y = Math.max(avatar.position.y + vel.y*dt, AVATAR_SIZE/2); avatar.position.z += vel.z*dt;

      // Kare sınır clamp'ı büyük bırakıyoruz; gerçek sınırı groundYAt belirler
      const minX = -planeSize/2 + AVATAR_SIZE/2, maxX = planeSize/2 - AVATAR_SIZE/2, minZ = -planeSize/2 + AVATAR_SIZE/2, maxZ = planeSize/2 - AVATAR_SIZE/2;
      avatar.position.x = Math.min(Math.max(avatar.position.x, minX), maxX);
      avatar.position.z = Math.min(Math.max(avatar.position.z, minZ), maxZ);

      if (insideStageXZ(avatar.position.x, avatar.position.z) && (avatar.position.y - AVATAR_SIZE/2) < (stageTopY + 0.01)){
        avatar.position.x = prev.x; avatar.position.z = prev.z; vel.x = 0; vel.z = 0;
      }

      if (typeof roomBlock === 'function')      roomBlock(avatar.position, prev, AVATAR_SIZE/2);
      if (typeof buildingBlock === 'function')  buildingBlock(avatar.position, prev, AVATAR_SIZE/2);
      if (typeof boardBlock === 'function')     boardBlock(avatar.position, prev, AVATAR_SIZE/2);

      const nGY = groundYAt(avatar.position.x, avatar.position.z, AVATAR_SIZE/2) + AVATAR_SIZE/2;
      if (avatar.position.y < nGY){ avatar.position.y = nGY; vel.y = 0; }

      if (vel.lengthSq()>0.0001){ const dirY = Math.atan2(vel.x, vel.z); if(!Number.isNaN(dirY)) avatar.rotation.y = dirY; }

      // Animasyon
      avatar.userData.animBlend ??= 0;            
      avatar.userData.swingTime ??= 0;            
      const speed2D = Math.hypot(vel.x, vel.z);
      const targetRun = Math.min(1, speed2D / speed);
      const blendK = 12; 
      avatar.userData.animBlend += (targetRun - avatar.userData.animBlend) * Math.min(1, dt * blendK);
      if (avatar.userData.animBlend < 0.05) avatar.userData.swingTime = 0; 
      const freq = THREE.MathUtils.lerp(2.0, 6.0, avatar.userData.animBlend);
      avatar.userData.swingTime += dt * freq;
      const amp  = THREE.MathUtils.lerp(0.1, 0.6, avatar.userData.animBlend);
      const s = Math.sin(avatar.userData.swingTime);
      const { aL, aR, lL, lR } = avatar.userData.limbs;
      aL.rotation.x =  s * amp;
      aR.rotation.x = -s * amp;
      lL.rotation.x = -s * amp;
      lR.rotation.x =  s * amp;
      if(!onGround){ aL.rotation.x += 0.6; aR.rotation.x += 0.6; }

      const desiredTarget = avatar.position.clone(); const deltaTarget = desiredTarget.clone().sub(controls.target); camera.position.add(deltaTarget); controls.target.copy(avatar.position);
    }
  </script>

  <!-- WORLD FX (Phase 1: Fog + Horizon Curtain + Gradient Sky) (Phase 2: Day/Night) (Phase 3: Distant Props) -->
  <script type="module" id="mod-worldfx">
    import * as THREE from 'three';
    export function createWorldFX(THREE, scene, { planeSize }, { amb, sun }){
      const group = new THREE.Group(); scene.add(group);

      // --- Phase 1: Fog + Horizon Curtain + Gradient Sky Dome ---
      let skyTopDay = new THREE.Color(0x87b7ff);
      let skyBotDay = new THREE.Color(0xcfe8ff);
      let skyTopNight = new THREE.Color(0x0a0d1a);
      let skyBotNight = new THREE.Color(0x182033);

      scene.fog = new THREE.FogExp2(skyBotDay.clone(), 0.0012);

      const skyGeo = new THREE.SphereGeometry(5000, 32, 16);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          topColor:   { value: skyTopDay.clone() },
          bottomColor:{ value: skyBotDay.clone() },
          offset:     { value: 33 },
          exponent:   { value: 0.6 }
        },
        vertexShader: `varying vec3 vWorldPosition; void main(){ vec4 p = modelMatrix * vec4(position,1.0); vWorldPosition = p.xyz; gl_Position = projectionMatrix * viewMatrix * p; }`,
        fragmentShader: `uniform vec3 topColor; uniform vec3 bottomColor; uniform float offset; uniform float exponent; varying vec3 vWorldPosition; void main(){ float h = normalize(vWorldPosition + vec3(0.0, offset, 0.0)).y; float f = max(pow(max(h, 0.0), exponent), 0.0); gl_FragColor = vec4( mix(bottomColor, topColor, f), 1.0 ); }`
      });
      const sky = new THREE.Mesh(skyGeo, skyMat); group.add(sky);

      // Horizon curtain: içe bakan geniş silindir
      const r = planeSize*0.8; // bahçenin ötesinde
      const curtain = new THREE.Mesh(
        new THREE.CylinderGeometry(r, r, 200, 48, 1, true),
        new THREE.MeshStandardMaterial({ color: 0x7aa7ff, metalness:0.0, roughness:1.0, side: THREE.BackSide, transparent:true, opacity:0.85 })
      );
      curtain.position.y = 100; // yarı yükseklik
      group.add(curtain);

      // --- Phase 3: Distant props ring (hafif ağaçlar) ---
      const props = new THREE.Group(); group.add(props);
      function addTree(px, pz){
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 4, 6), new THREE.MeshStandardMaterial({ color: 0x6e4b2a, roughness:0.9 }));
        trunk.position.set(px, 2, pz); trunk.castShadow=true; props.add(trunk);
        const cone = new THREE.Mesh(new THREE.ConeGeometry(2.5, 6, 8), new THREE.MeshStandardMaterial({ color: 0x2b7a2b, roughness:0.8 }));
        cone.position.set(px, 7, pz); cone.castShadow=true; props.add(cone);
      }
      const ringR = planeSize*0.6 + 40; const count = 28; // dairesel zeminin içinde kalır
      for(let i=0;i<count;i++){
        const a = i / count * Math.PI*2;
        const px = Math.cos(a) * ringR;
        const pz = Math.sin(a) * ringR;
        addTree(px, pz);
      }

      // --- Phase 2: Day/Night basit harmanlama ---
      function dayNightFactor(date){
        const h = date.getHours() + date.getMinutes()/60; // 0..24
        const t = Math.cos((h-12)/12 * Math.PI); // 1 (öğlen) -> -1 (gece yarısı)
        return (t+1)/2; // 0..1 (0=gece,1=gündüz)
      }
      function updateLights(t){
        const colTop = skyTopNight.clone().lerp(skyTopDay, t);
        const colBot = skyBotNight.clone().lerp(skyBotDay, t);
        sky.material.uniforms.topColor.value.copy(colTop);
        sky.material.uniforms.bottomColor.value.copy(colBot);
        const fogCol = colBot.clone();
        scene.fog.color.copy(fogCol);
        amb.intensity = 0.25 + 0.55*t;
        sun.intensity = 0.2  + 0.9*t;
        sun.color.copy(new THREE.Color(0xffe7b0).lerp(new THREE.Color(0xffffff), t));
        curtain.material.color.copy(colBot.clone().lerp(colTop, 0.3));
      }

      updateLights(dayNightFactor(new Date()));

      return {
        update(){
          const t = dayNightFactor(new Date());
          updateLights(t);
        }
      };
    }
  </script>

  <!-- Main -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'orbit';

    async function importById(id){
      const el = document.getElementById(id);
      if(!el) throw new Error(`Modül bulunamadı: ${id}`);
      const code = el.textContent;
      const blob = new Blob([code], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      try { return await import(url); } finally { URL.revokeObjectURL(url); }
    }

    const utils                          = await importById('mod-utils');
    const { createSceneSetup }           = await importById('mod-scene');
    const { createInput }                = await importById('mod-input');
    const { createGarden }               = await importById('mod-garden');
    const { createGlassRoom }            = await importById('mod-glassroom');
    const { createNftBuilding }          = await importById('mod-nft-building');
    const { AvatarFactory, updateAvatar }= await importById('mod-entities');
    const { createWorldFX }              = await importById('mod-worldfx');

    const hud = document.getElementById('hud');
    const nameTag = document.getElementById('nameTag');

    const { scene, camera, renderer, controls, amb, sun } = createSceneSetup(THREE, OrbitControls);
    const keys = createInput();

    const { planeSize, groundR, stage, STAGE_W, STAGE_D, STAGE_H, insideStageXZ, groundYAt, boardBlock } = createGarden(THREE, scene);
    const stageTopY = stage.position.y + STAGE_H/2;

    // Camlı oda: sahne ile aynı boyut; haritanın en sağ kenarı
    const roomPos = new THREE.Vector3( planeSize/2 - STAGE_W/2, 0, 0 );
    const { room: glassRoom, block: roomBlock } = createGlassRoom(THREE, scene, { w: STAGE_W, d: STAGE_D, position: roomPos });

    // NFT Bina: garden sol-orta; merkez (5,0,135)
    const nftPos = new THREE.Vector3(5, 0, 135);
    const { building: nftBuilding, block: buildingBlock } = createNftBuilding(THREE, scene, { w: 60, d: 40, h: 22, position: nftPos, doorRatio: 0.35 });

    // WORLD FX (Phases 1-3)
    const worldfx = createWorldFX(THREE, scene, { planeSize }, { amb, sun });

    // Avatar
    const avatarFactory = AvatarFactory(THREE);
    const avatar = avatarFactory.create();
    scene.add(avatar);

    // Spawn: odanın içinde, sahneye (batıya) dönük
    avatar.position.set(roomPos.x, 1, roomPos.z);
    avatar.rotation.y = -Math.PI/2; // sahneye bakış

    // Kamera: sahneye doğru baksın
    camera.position.set(avatar.position.x + 12, avatar.position.y + 8, avatar.position.z + 0);
    controls.target.copy(avatar.position);

    function updateNameTag(){
      const pos = avatar.position.clone();
      pos.y += 3.2; // kafanın biraz üstü
      pos.project(camera);
      const out = (Math.abs(pos.x) > 1 || Math.abs(pos.y) > 1 || pos.z > 1);
      if(out){ nameTag.classList.add('hidden'); return; }
      nameTag.classList.remove('hidden');
      const x = (pos.x * 0.5 + 0.5) * innerWidth;
      const y = (-pos.y * 0.5 + 0.5) * innerHeight;
      nameTag.style.transform = `translate(-50%, -100%) translate(${x}px, ${y}px)`;
    }

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      updateAvatar(THREE, dt, avatar, keys, camera, controls, { insideStageXZ, groundYAt, planeSize, stageTopY, roomBlock, buildingBlock, boardBlock });
      worldfx.update(dt);
      controls.update();
      renderer.render(scene, camera);

      // HUD
      const heading = ((utils.deg(avatar.rotation.y) % 360) + 360) % 360;
      hud.textContent = `x: ${utils.fmt(avatar.position.x)}\ny: ${utils.fmt(avatar.position.y)}\nz: ${utils.fmt(avatar.position.z)}\nrotY: ${heading.toFixed(1)}°`;
      updateNameTag();
    }
    animate();
  </script>
</body>
</html>
